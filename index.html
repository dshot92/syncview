<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="Synchronized dual-map viewer for comparing locations and distances">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Sync View">
    <meta property="og:description" content="Synchronized dual-map viewer for comparing locations and distances">
    <meta property="og:image" content="https://dshot92.github.io/syncview/images/preview.webp">
    <meta property="og:image:secure_url" content="https://dshot92.github.io/syncview/images/preview.webp">
    <meta property="og:image:type" content="image/webp">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Sync View">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Sync View">
    <meta name="twitter:description" content="Synchronized dual-map viewer for comparing locations and distances">
    <meta name="twitter:image" content="https://dshot92.github.io/syncview/images/preview.webp">
    <meta name="twitter:image:alt" content="Sync View preview">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sync View">
    <title>Sync View</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="images/icon.svg">
    <link rel="apple-touch-icon" href="images/icon.svg">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root {
            --bg-deep: #020617;
            --accent-blue: #3b82f6;
            --accent-yellow: #fbbf24;
            --accent-red: #f43f5e;
            --text-color: #fff;
            --text-main: #fff;
            --border: 1px solid rgba(255, 255, 255, 0.1);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            --radius: 12px;
            --origin-color: var(--accent-blue);
            --comp-color: var(--accent-yellow);

            /* Shape & Line Variables */
            --shape-line-width: 3;
            --shape-point-size: 20px;
            --shape-outline-color: var(--bg-deep);
            --shape-point-color: var(--accent-blue);

            /* Bounding Box Variables */
            --bbox-color: var(--accent-red);
            --bbox-width: 1.5;

            /* Standardized UI Sizes */
            --pill-height: 44px;
            --pill-width: 44px;
            --pill-rect-width: 72px;
            --bar-gap: 4px;
            --btn-radius: 16px;
            --lens-size: 140px;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            user-select: none;
        }

        input,
        textarea {
            -webkit-user-select: auto;
            user-select: auto;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background: var(--bg-deep);
            color: var(--text-color);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100%;
            width: 100%;
        }

        .map-wrapper {
            position: relative;
            border-right: var(--border);
            display: grid;
            grid-template-rows: 1fr;
            grid-template-columns: 1fr;
            overflow: hidden;
        }

        .map-instance {
            grid-area: 1 / 1;
            background: #0b0e14;
            cursor: crosshair;
            z-index: 1;
        }

        .overlay-ui {
            grid-area: 1 / 1;
            pointer-events: none;
            z-index: 1000;
            position: relative;
            height: 100%;
            width: 100%;
        }

        .hud-stack {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .hud-card {
            background: var(--bg-deep);
            backdrop-filter: blur(12px);
            border: var(--border);
            border-radius: var(--btn-radius);
            padding: 6px 12px;
            pointer-events: auto;
            min-width: 110px;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: translateY(-10px);
            text-align: center;
        }

        .hud-card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Icon Centering & Styling */
        img {
            filter: brightness(0) invert(1);
            width: 18px;
            height: 18px;
            display: block;
            margin: 0;
            pointer-events: none;
        }



        .stats-val {
            font-size: 20px;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            line-height: 1.1;
        }

        .stats-diff {
            font-size: 12px;
            font-weight: 700;
            margin-top: 1px;
        }

        .toolbar-container {
            position: absolute;
            top: 16px;
            left: 16px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            border-radius: var(--btn-radius);
            background: var(--bg-deep);
            backdrop-filter: blur(10px);
            border: var(--border);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-lg);
            pointer-events: auto;
            padding: 0;
            overflow: hidden;
        }

        @media (hover: hover) {
            .tool-btn:hover {
                background: #161b2c;
                transform: translateY(-2px);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            }

            .tool-btn.danger:hover {
                background: #ff5f78;
            }
        }

        .tool-btn.danger {
            background-color: var(--accent-red);
        }

        .tool-btn.loading img {
            display: none;
        }

        .tool-btn.loading::after {
            content: '';
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .map-point-icon {
            border: 2px solid var(--shape-outline-color);
            background-color: var(--shape-point-color);
            border-radius: 50%;
            width: var(--shape-point-size) !important;
            height: var(--shape-point-size) !important;
            margin-left: calc(var(--shape-point-size) / -2) !important;
            margin-top: calc(var(--shape-point-size) / -2) !important;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            display: flex !important;
            align-items: center;
            justify-content: center;
            color: var(--text-main);
            font-size: 10px;
            font-weight: 900;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            cursor: grab;
        }

        .handle-icon {
            width: 32px;
            height: 32px;
            background: var(--accent-yellow);
            border: 2px solid var(--shape-outline-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            cursor: grab;
        }

        @media (hover: hover) {
            .handle-icon:hover {
                filter: brightness(1.1);
            }
        }

        .handle-icon img {
            width: 20px;
            height: 20px;
            filter: none !important;
            pointer-events: none;
        }

        .handle-move {
            cursor: move;
        }

        .handle-rotate {
            cursor: grab;
        }

        .search-wrapper {
            position: relative;
            pointer-events: auto;
        }

        .search-control {
            display: flex;
            align-items: center;
            background: var(--bg-deep);
            backdrop-filter: blur(10px);
            border: var(--border);
            border-radius: var(--btn-radius);
            height: 44px;
            width: 44px;
            overflow: hidden;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s;
            box-shadow: var(--shadow-lg);
        }

        .search-control.expanded {
            width: 280px;
            border-radius: var(--btn-radius);
        }

        /* Fix search icon alignment */
        .search-btn-inner {
            flex-shrink: 0;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
            border-radius: inherit;
            transition: background 0.2s;
        }

        @media (hover: hover) {
            .search-btn-inner:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .search-input {
            width: 0;
            opacity: 0;
            background: transparent;
            border: none;
            color: var(--text-main);
            padding: 0;
            font-size: 14px;
            outline: none;
        }

        .search-control.expanded .search-input {
            width: 100%;
            opacity: 1;
            padding: 0 12px;
        }

        .search-results {
            position: absolute;
            left: 0;
            width: 280px;
            top: 50px;
            background: var(--bg-deep);
            backdrop-filter: blur(20px);
            border: var(--border);
            border-radius: var(--btn-radius);
            max-height: 250px;
            overflow-y: auto;
            display: none;
            flex-direction: column;
            z-index: 1001;
            box-shadow: var(--shadow-lg);
            padding: 6px;
        }

        .results-list {
            display: flex;
            flex-direction: column;
        }

        .result-item {
            padding: 10px 12px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-main);
            border-radius: calc(var(--btn-radius) - 6px);
            transition: all 0.2s;
        }

        @media (hover: hover) {
            .result-item:hover {
                background: rgba(255, 255, 255, 0.05);
                color: var(--text-main);
            }
        }

        /* GLOBAL BAR STYLING */
        .global-bar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            background: var(--bg-deep);
            padding: 6px;
            border-radius: calc(var(--btn-radius) + 4px);
            border: var(--border);
            display: flex;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            align-items: center;
            gap: var(--bar-gap);
        }

        .bar-btn {
            width: var(--pill-width);
            height: var(--pill-height);
            border-radius: var(--btn-radius);
            background: transparent;
            border: none;
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            padding: 0;
        }

        @media (hover: hover) {
            .bar-btn:hover {
                background: rgba(255, 255, 255, 0.08);
                transform: translateY(-2px);
            }
        }

        .bar-btn.active {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #center-btn1, #center-btn2 {
            display: flex;
        }

        .global-bar .bar-btn.center-btn {
            display: none;
        }



        /* MODE PILLS */
        .pill-group {
            display: flex;
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--btn-radius);
            gap: var(--bar-gap);
        }

        .pill-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: var(--pill-rect-width);
            height: var(--pill-height);
            background: var(--accent-blue);
            border-radius: var(--btn-radius);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
        }

        .pill {
            width: var(--pill-rect-width);
            height: var(--pill-height);
            border-radius: var(--btn-radius);
            /* font-weight: 700; */
            font-size: 1rem;
            text-transform: uppercase;
            cursor: pointer;
            border: none;
            background: transparent;
            color: var(--text-main);
            transition: color 0.3s;
            position: relative;
            z-index: 1;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .pill.active {
            color: var(--bg-deep);
        }

        #mode-group[data-mode="area"] .pill-bg {
            transform: translateX(calc(var(--pill-rect-width) + var(--bar-gap)));
        }

        /* REFINED DROPDOWN */
        .dropdown-container {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            bottom: calc(100% + 16px);
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: var(--bg-deep);
            border: var(--border);
            border-radius: var(--btn-radius);
            min-width: 160px;
            padding: 6px;
            box-shadow: var(--shadow-lg);
            display: none;
            flex-direction: column;
            gap: 4px;
            opacity: 0;
            transition: all 0.2s ease-out;
            pointer-events: none;
        }

        .dropdown-menu.show {
            display: flex;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        .dropdown-item {
            height: 40px;
            padding: 0 16px;
            border-radius: calc(var(--btn-radius) - 4px);
            color: var(--text-main);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            z-index: 1;
            transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @media (hover: hover) {
            .dropdown-item:hover {
                color: var(--text-main);
            }
        }

        .dropdown-item.active {
            color: var(--bg-deep);
        }

        .dropdown-highlight {
            position: absolute;
            top: 6px;
            left: 6px;
            width: calc(100% - 12px);
            height: 40px;
            background: var(--accent-blue);
            border-radius: calc(var(--btn-radius) - 4px);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            pointer-events: none;
        }

        #layerMenu[data-active="hybrid"] .dropdown-highlight {
            transform: translateY(0);
        }

        #layerMenu[data-active="satellite"] .dropdown-highlight {
            transform: translateY(calc(40px + 4px));
        }

        #layerMenu[data-active="streets"] .dropdown-highlight {
            transform: translateY(calc((40px + 4px) * 2));
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            z-index: 3000;
            display: none;
            place-items: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .modal-overlay.show {
            display: grid;
            opacity: 1;
        }

        .modal-content {
            background: var(--bg-deep);
            backdrop-filter: blur(20px);
            border: var(--border);
            border-radius: calc(var(--btn-radius) * 1.5);
            width: 90%;
            max-width: 480px;
            padding: 24px;
            box-shadow: var(--shadow-lg);
            color: var(--text-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            cursor: pointer;
        }

        .setting-value {
            color: var(--accent-blue);
            font-weight: 700;
        }

        .btn-link-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 20px 0;
        }

        .btn-link {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: var(--border);
            border-radius: var(--btn-radius);
            padding: 10px;
            color: var(--text-main);
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        @media (hover: hover) {
            .btn-link:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .shortcut-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            font-size: 13px;
        }

        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: 800;
            color: var(--accent-blue);
            min-width: 24px;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        /* SHARE MODAL STYLING */
        .share-qr-container {
            background: white;
            padding: 16px;
            border-radius: var(--radius);
            margin: 20px auto;
            width: fit-content;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        #qrcode img {
            filter: none;
            /* Keep QR code black and white */
            width: 200px;
            height: 200px;
        }

        .share-url-display {
            background: rgba(255, 255, 255, 0.05);
            border: var(--border);
            border-radius: var(--btn-radius);
            padding: 14px;
            font-family: monospace;
            font-size: 13px;
            word-break: break-all;
            margin-bottom: 20px;
            color: var(--text-main);
            max-height: 120px;
            overflow-y: auto;
            user-select: text;
            /* Allow users to select the link */
        }

        .btn-primary {
            background: var(--accent-blue);
            color: var(--text-main);
            border: none;
            border-radius: var(--btn-radius);
            padding: 14px;
            font-weight: 700;
            width: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s;
        }

        @media (hover: hover) {
            .btn-primary:hover {
                filter: brightness(1.1);
                transform: translateY(-2px);
            }
        }

        @media (max-width: 768px) {
            #app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr;
            }

            .map-wrapper {
                border-right: none;
                border-bottom: var(--border);
            }

            /* Map 1 (Top Map) - Anchor UI to the bottom edge (center of screen) */
            #map1-wrapper .toolbar-container {
                top: auto;
                bottom: 16px;
                flex-direction: column-reverse;
            }

            #map1-wrapper .hud-stack {
                top: auto;
                bottom: 16px;
                flex-direction: column-reverse;
            }

            #map1-wrapper .search-results {
                top: auto;
                bottom: 50px;
                flex-direction: column-reverse;
            }

            #map1-wrapper .results-list {
                flex-direction: column-reverse;
            }

            /* Map 2 (Bottom Map) - Anchor UI to the top edge (center of screen) */
            #map2-wrapper .toolbar-container {
                top: 16px;
                flex-direction: column;
            }

            #map2-wrapper .hud-stack {
                top: 16px;
                flex-direction: column;
            }

            .global-bar {
                bottom: 16px;
                padding: 4px;
                --bar-gap: 2px;
            }

            #share-modal {
                display: none !important;
            }
        }

        #magnifier {
            position: fixed;
            width: var(--lens-size);
            height: var(--lens-size);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), inset 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            pointer-events: none;
            display: none;
            overflow: hidden;
            background: #000;
        }

        #magnifier::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            z-index: 10001;
        }

        /* REPLACING INLINE STYLES */
        .modal-header h2 {
            margin: 0;
        }

        .modal-header .tool-btn {
            width: 32px;
            height: 32px;
        }

        .info-intro {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 0;
            color: var(--text-main);
        }

        .shortcut-title {
            font-size: 15px;
            margin-bottom: 12px;
        }

        .btn-primary img {
            width: 20px;
            height: 20px;
        }

        .qr-status {
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }

        .qr-status.loading {
            color: var(--accent-blue);
        }

        .qr-status.error {
            color: var(--accent-red);
        }

        .search-status {
            opacity: 0.6;
            cursor: default;
            color: var(--text-main);
        }

        .search-status.searching {
            cursor: wait;
        }

        .search-status.error {
            color: var(--accent-red);
            opacity: 1;
        }
    </style>
</head>

<body>

    <div id="app-container">
        <!-- Wrap each map and its overlay for better scoping -->
        <div class="map-wrapper" id="map1-wrapper">
            <div id="map1" class="map-instance"></div>
            <div class="overlay-ui">
                <div class="hud-stack">
                    <div class="hud-card" id="card1">
                        <div id="stats1" class="stats-val">---</div>
                        <div id="diff1" class="stats-diff"></div>
                    </div>
                </div>
                <div class="toolbar-container">
                    <div class="search-wrapper">
                        <div class="search-control" id="search-ctrl1">
                            <button class="search-btn-inner" onclick="toggleSearch(1)">
                                <img src="images/svgs/search.svg" alt="">
                            </button>
                            <input type="text" class="search-input" id="search-in1" placeholder="Search world..."
                                oninput="debouncedSearch(event, 1)" autocomplete="off" autocorrect="off"
                                autocapitalize="off" spellcheck="false">
                        </div>
                        <div id="results1" class="search-results">
                            <div id="status-searching1" class="result-item search-status searching hidden">Searching...
                            </div>
                            <div id="status-none1" class="result-item search-status hidden">No results found</div>
                            <div id="status-error1" class="result-item search-status error hidden">Search error. Check
                                connection.</div>
                            <div id="results-list1" class="results-list"></div>
                        </div>
                    </div>
                    <button class="tool-btn" id="locate-btn1" onclick="locateDevice(1)">
                        <img src="images/svgs/device-position.svg" alt="">
                    </button>
                    <button id="center-btn1" class="tool-btn hidden" onclick="centerShapes()">
                        <img src="images/svgs/center.svg" alt="">
                    </button>
                    <button id="back1" class="tool-btn hidden" onclick="AppState.removeLast()">
                        <img src="images/svgs/back.svg" alt="">
                    </button>
                    <button id="clear1" class="tool-btn danger hidden" onclick="AppState.clear()">
                        <img src="images/svgs/clear.svg" alt="">
                    </button>
                </div>
            </div>
        </div>

        <div class="map-wrapper" id="map2-wrapper">
            <div id="map2" class="map-instance"></div>
            <div class="overlay-ui">
                <div class="hud-stack">
                    <div class="hud-card" id="card2">
                        <div id="stats2" class="stats-val">---</div>
                        <div id="diff2" class="stats-diff"></div>
                    </div>
                </div>
                <div class="toolbar-container">
                    <div class="search-wrapper">
                        <div class="search-control" id="search-ctrl2">
                            <button class="search-btn-inner" onclick="toggleSearch(2)">
                                <img src="images/svgs/search.svg" alt="">
                            </button>
                            <input type="text" class="search-input" id="search-in2" placeholder="Search world..."
                                oninput="debouncedSearch(event, 2)" autocomplete="off" autocorrect="off"
                                autocapitalize="off" spellcheck="false">
                        </div>
                        <div id="results2" class="search-results">
                            <div id="status-searching2" class="result-item search-status searching hidden">Searching...
                            </div>
                            <div id="status-none2" class="result-item search-status hidden">No results found</div>
                            <div id="status-error2" class="result-item search-status error hidden">Search error. Check
                                connection.</div>
                            <div id="results-list2" class="results-list"></div>
                        </div>
                    </div>
                    <button class="tool-btn" id="locate-btn2" onclick="locateDevice(2)">
                        <img src="images/svgs/device-position.svg" alt="">
                    </button>
                    <button id="center-btn2" class="tool-btn hidden" onclick="centerShapes()">
                        <img src="images/svgs/center.svg" alt="">
                    </button>
                    <button id="back2" class="tool-btn hidden" onclick="AppState.removeLast()">
                        <img src="images/svgs/back.svg" alt="">
                    </button>
                    <button id="clear2" class="tool-btn danger hidden" onclick="AppState.clear()">
                        <img src="images/svgs/clear.svg" alt="">
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="global-bar">
        <button class="bar-btn" onclick="toggleModal('settings-modal', true)">
            <img src="images/svgs/settings.svg" alt="">
        </button>



        <div class="dropdown-container">
            <button class="bar-btn" id="layerBtn" onclick="toggleLayerMenu()">
                <img src="images/svgs/layers.svg" alt="">
            </button>
            <div class="dropdown-menu" id="layerMenu" data-active="hybrid">
                <div class="dropdown-highlight"></div>
                <div data-layer="hybrid" class="dropdown-item active" onclick="AppState.setLayer('hybrid')">Hybrid</div>
                <div data-layer="satellite" class="dropdown-item" onclick="AppState.setLayer('satellite')">Satellite
                </div>
                <div data-layer="streets" class="dropdown-item" onclick="AppState.setLayer('streets')">Streets</div>
            </div>
        </div>



        <div class="pill-group" id="mode-group" data-mode="line">
            <div class="pill-bg"></div>
            <button id="btnLine" class="pill active" onclick="AppState.setMode('line')">Line</button>
            <button id="btnArea" class="pill" onclick="AppState.setMode('area')">Area</button>
        </div>



        <button class="bar-btn" onclick="shareCurrentView()">
            <img src="images/svgs/share.svg" alt="">
        </button>

        <button class="bar-btn center-btn" onclick="centerShapes()">
            <img src="images/svgs/center.svg" alt="">
        </button>

        <button class="bar-btn" onclick="toggleModal('info-modal', true)">
            <img src="images/svgs/info.svg" alt="">
        </button>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settings-modal" class="modal-overlay" onclick="toggleModal('settings-modal', false)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="tool-btn" onclick="toggleModal('settings-modal', false)">×</button>
            </div>
            <div class="setting-row" onclick="AppState.toggleUnits()">
                <span>Measurement Units</span>
                <span id="val-units" class="setting-value">Metric</span>
            </div>
            <div class="setting-row" onclick="AppState.toggleVertexNumbers()">
                <span>Show Point Numbers</span>
                <span id="val-vertex" class="setting-value">Off</span>
            </div>
            <div class="setting-row" onclick="AppState.toggleBoundingBox()">
                <span>Show Bounding Box</span>
                <span id="val-bbox" class="setting-value">Off</span>
            </div>
        </div>
    </div>

    <!-- INFO MODAL -->
    <div id="info-modal" class="modal-overlay" onclick="toggleModal('info-modal', false)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>Sync View</h2>
                <button class="tool-btn" onclick="toggleModal('info-modal', false)">×</button>
            </div>
            <p class="info-intro">
                Sync View is a dual-map comparison tool for measuring distances and areas between locations.
            </p>

            <div class="btn-link-group">
                <a href="https://github.com/dshot92/syncview" target="_blank" class="btn-link">
                    <img src="images/svgs/github.svg" alt="">
                    Sync View
                </a>
                <a href="https://github.com/dshot92" target="_blank" class="btn-link">
                    <img src="images/svgs/github.svg" alt="">
                    dshot92
                </a>
            </div>

            <h3 class="shortcut-title">Keyboard Shortcuts</h3>
            <div class="shortcut-grid">
                <div class="shortcut-item"><span class="key">L</span> <span>Line mode</span></div>
                <div class="shortcut-item"><span class="key">A</span> <span>Area mode</span></div>
                <div class="shortcut-item"><span class="key">U</span> <span>Toggle units</span></div>
                <div class="shortcut-item"><span class="key">V</span> <span>Vertex numbers</span></div>
                <div class="shortcut-item"><span class="key">B</span> <span>Bounding box</span></div>
                <div class="shortcut-item"><span class="key">Del</span> <span>Remove last point</span></div>
                <div class="shortcut-item"><span class="key">Z</span> <span>Undo (Ctrl+Z)</span></div>
                <div class="shortcut-item"><span class="key">Esc</span> <span>Close / Clear</span></div>
            </div>
        </div>
    </div>

    <!-- SHARE MODAL -->
    <div id="share-modal" class="modal-overlay" onclick="toggleModal('share-modal', false)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>Share</h2>
                <button class="tool-btn" onclick="toggleModal('share-modal', false)">×</button>
            </div>

            <div class="share-qr-container">
                <div id="qr-loading" class="qr-status loading hidden">GENERATING QR...</div>
                <div id="qr-error" class="qr-status error hidden">QR Error</div>
                <div id="qrcode"></div>
            </div>

            <div id="share-url" class="share-url-display"></div>

            <button class="btn-primary" id="btn-copy-link">
                <img src="images/svgs/copy.svg" alt="">
                <span>Copy Link</span>
            </button>
        </div>
    </div>

    <div id="magnifier"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script>
        const tiles = {
            hybrid: 'https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
            satellite: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
            streets: 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
        };

        const layerOrder = Object.keys(tiles);
        const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

        class Shape {
            constructor(anchor, originMapId, initialCompAnchor) {
                this.origin_map = originMapId;
                this.origin_anchor = L.latLng(anchor);
                // Use the provided initial anchor for the comparison map
                this.comparison_anchor = L.latLng(initialCompAnchor);
                this.localPoints = [L.point(0, 0)];
                this.overlayRotation = 0; // radians
            }

            getCentroid() {
                if (this.localPoints.length === 0) return L.point(0, 0);
                let x = 0, y = 0;
                this.localPoints.forEach(p => { x += p.x; y += p.y; });
                return L.point(x / this.localPoints.length, y / this.localPoints.length);
            }

            shiftComparisonAnchor(map, oldCentroid, newCentroid) {
                const diff = newCentroid.subtract(oldCentroid);
                const rot = this.overlayRotation;
                const sin = Math.sin(rot);
                const cos = Math.cos(rot);
                const rx = diff.x * cos - diff.y * sin;
                const ry = diff.x * sin + diff.y * cos;
                const compAnchorPx = map.project(this.comparison_anchor, AppState.REF_ZOOM);
                this.comparison_anchor = map.unproject(compAnchorPx.add(L.point(rx, ry)), AppState.REF_ZOOM);
            }

            addPoint(latlng, map, index = -1) {
                const c1 = this.getCentroid();
                const anchorPx = map.project(this.origin_anchor, AppState.REF_ZOOM);
                const pointPx = map.project(latlng, AppState.REF_ZOOM);
                const rel = pointPx.subtract(anchorPx);
                if (index === -1) this.localPoints.push(rel);
                else this.localPoints.splice(index, 0, rel);
                this.shiftComparisonAnchor(map, c1, this.getCentroid());
            }

            updatePoint(index, newLatLng, map) {
                const c1 = this.getCentroid();
                const anchorPx = map.project(this.origin_anchor, AppState.REF_ZOOM);
                const pointPx = map.project(newLatLng, AppState.REF_ZOOM);
                this.localPoints[index] = pointPx.subtract(anchorPx);
                this.shiftComparisonAnchor(map, c1, this.getCentroid());
            }

            removeLastPoint(map) {
                if (this.localPoints.length === 0) return;
                const c1 = this.getCentroid();
                this.localPoints.pop();
                if (this.localPoints.length === 0) return;
                this.shiftComparisonAnchor(map, c1, this.getCentroid());
            }

            getRenderPoints(targetMap, targetMapId) {
                const currentZoom = targetMap.getZoom();
                const scale = Math.pow(2, currentZoom - AppState.REF_ZOOM);

                // For Origin Map: Render exactly as stored (relative to origin anchor)
                if (targetMapId === this.origin_map) {
                    const anchorPx = targetMap.project(this.origin_anchor, currentZoom);
                    return this.localPoints.map(p => {
                        return targetMap.unproject(anchorPx.add(p.multiplyBy(scale)), currentZoom);
                    });
                }

                // For Comparison Map: Render centered on comparison_anchor (Handle)
                // 1. Calculate centroid of local points (unscaled)
                const centroid = this.getCentroid();

                // 2. Project comparison anchor (Handle position)
                const anchorPx = targetMap.project(this.comparison_anchor, currentZoom);

                // 3. Precompute rotation
                const rot = this.overlayRotation;
                const sin = Math.sin(rot);
                const cos = Math.cos(rot);

                return this.localPoints.map(p => {
                    // Center the point relative to the centroid
                    const cx = (p.x - centroid.x) * scale;
                    const cy = (p.y - centroid.y) * scale;

                    // Rotate the centered point
                    const rx = cx * cos - cy * sin;
                    const ry = cx * sin + cy * cos;

                    // Add rotated offset to the handle position
                    return targetMap.unproject(anchorPx.add(L.point(rx, ry)), currentZoom);
                });
            }

            setOverlayPosition(latlng) {
                this.comparison_anchor = latlng;
            }

            setOverlayRotation(angle) {
                this.overlayRotation = angle;
            }
        }

        // Shared options — both maps are identical
        const mapOptions = {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: 0,           // continuous zoom — fires zoom event on every frame during pinch
            zoomDelta: 0.5,        // step size per click/key press (snapped to this, not scale)
            wheelPxPerZoomLevel: 120,
            inertia: true,
            inertiaDeceleration: 3000,
        };
        const map1 = L.map('map1', mapOptions).setView([51.505, -0.09], 13);
        const map2 = L.map('map2', mapOptions).setView([40.7128, -74.0060], 13);

        const tileOptions = {
            updateWhenZooming: true,  // request tiles during zooming
            updateWhenIdle: false,    // load tiles immediately
            keepBuffer: 4,            // cache 4 tiles around the viewport
            minZoom: 1,
            maxZoom: 22,
            tileSize: 256,
        };
        let tile1 = L.tileLayer(tiles.hybrid, { ...tileOptions }).addTo(map1);
        let tile2 = L.tileLayer(tiles.hybrid, { ...tileOptions }).addTo(map2);


        // ── Real-time simultaneous zoom sync ─────────────────────────────────────
        //
        // During a pinch, Leaflet fires 'zoom' each frame on the active map.
        // We mirror that as a CSS scale() on the passive map — GPU only, zero
        // tile requests, perfectly smooth.
        //
        // On touchend: Leaflet's handler on #map1/#map2 fires FIRST (inner element
        // in bubbling order), so the active map's zoom is already finalised by the
        // time our handler fires on #app-container. We call setZoom directly on
        // the passive map so both maps start loading tiles at the same instant.

        let activePinchMap = null;
        let passivePinchMap = null;
        let passiveBaseZoom = null;
        let justEndedPinch = false;  // suppress bindZoom double-sync right after pinch

        function onActiveMapZoom() {
            if (!passivePinchMap) return;
            const scale = Math.pow(2, activePinchMap.getZoom() - passiveBaseZoom);
            // Scale the passive map's _mapPane — exactly what Leaflet does internally
            // for its own animated zoom. Same element, same approach = same visual rate.
            const size = passivePinchMap.getSize();
            const origin = L.point(size.x / 2, size.y / 2);
            const offset = origin.subtract(origin.multiplyBy(scale));
            L.DomUtil.setTransform(passivePinchMap._mapPane, offset, scale);
        }

        function endPinch() {
            if (!passivePinchMap) return;
            activePinchMap.off('zoom', onActiveMapZoom);
            const passive = passivePinchMap;
            const active = activePinchMap;
            // Reset _mapPane transform — Leaflet will re-apply its own transform on setZoom
            L.DomUtil.setTransform(passive._mapPane, L.point(0, 0), 1);
            passivePinchMap = null;
            activePinchMap = null;
            passiveBaseZoom = null;
            // Leaflet already settled the active map's zoom (bubbling order: inner first).
            // Call setZoom directly so both maps load tiles at exactly the same time.
            justEndedPinch = true;
            const finalZoom = active.getZoom();
            if (Math.abs(passive.getZoom() - finalZoom) > 0.01) {
                passive.setZoom(finalZoom, { animate: false });
            }
            justEndedPinch = false;
        }

        document.getElementById('app-container').addEventListener('touchstart', e => {
            if (e.touches.length === 2) {
                if (passivePinchMap) endPinch(); // clean up any prior gesture
                const inMap1 = e.touches[0].target.closest('#map1-wrapper') ||
                    e.touches[1].target.closest('#map1-wrapper');
                activePinchMap = inMap1 ? map1 : map2;
                passivePinchMap = inMap1 ? map2 : map1;
                passiveBaseZoom = passivePinchMap.getZoom();
                activePinchMap.on('zoom', onActiveMapZoom);
            }
        }, { passive: true });

        document.getElementById('app-container').addEventListener('touchend', endPinch, { passive: true });
        document.getElementById('app-container').addEventListener('touchcancel', endPinch, { passive: true });

        // Fallback sync for double-tap / keyboard / scroll-wheel zoom (no pinch)
        let isSyncing = false;
        function bindZoom(source, target) {
            source.on('zoomend', () => {
                // Skip if we're inside a pinch, or if endPinch just synced
                if (isSyncing || passivePinchMap || justEndedPinch) return;
                isSyncing = true;
                const z = source.getZoom();
                if (Math.abs(target.getZoom() - z) > 0.01) {
                    target.setZoom(z, { animate: false });
                }
                isSyncing = false;
            });
        }
        bindZoom(map1, map2);
        bindZoom(map2, map1);



        const AppState = {
            REF_ZOOM: 20,
            groundTruth: null,
            mode: 'line',
            units: 'metric',
            markers: [],
            showVertexNumbers: false,
            showBoundingBox: false,
            isDragging: false,
            isRotating: false,
            isDraggingPoint: -1,
            isDragEnd: false,
            lensOffset: 40,
            showLens: true,
            magnifierMap: null,
            magnifierTile: null,

            init(anchor, originMapId) {
                const originMap = originMapId === 1 ? map1 : map2;
                const compMap = originMapId === 1 ? map2 : map1;

                // Match screen position for the first point so it appears exactly where clicked relative to the map container
                const screenPoint = originMap.latLngToContainerPoint(anchor);
                const initialCompAnchor = compMap.containerPointToLatLng(screenPoint);

                this.groundTruth = new Shape(anchor, originMapId, initialCompAnchor);
                this.updateUI();
                requestRender();
            },
            setMode(m) {
                this.mode = m;
                DOM.modeGroup.setAttribute('data-mode', m);
                DOM.btnLine.classList.toggle('active', m === 'line');
                DOM.btnArea.classList.toggle('active', m === 'area');
                resetLayers();
                requestRender();
            },
            setLayer(l) {
                map1.removeLayer(tile1); map2.removeLayer(tile2);
                tile1 = L.tileLayer(tiles[l], { ...tileOptions }).addTo(map1).bringToBack();
                tile2 = L.tileLayer(tiles[l], { ...tileOptions }).addTo(map2).bringToBack();
                map1.invalidateSize({ pan: false }); map2.invalidateSize({ pan: false });
                map1.setView(map1.getCenter(), map1.getZoom(), { animate: false });
                map2.setView(map2.getCenter(), map2.getZoom(), { animate: false });
                DOM.layerMenu.dataset.active = l;
                DOM.dropdownItems.forEach(item => {
                    item.classList.toggle('active', item.getAttribute('data-layer') === l);
                });
                setTimeout(() => DOM.layerMenu.classList.remove('show'), 200);
                DOM.layerBtn.classList.remove('active');
            },
            toggleUnits() {
                this.units = this.units === 'metric' ? 'imperial' : 'metric';
                DOM.valUnits.textContent = this.units.charAt(0).toUpperCase() + this.units.slice(1);
                requestRender();
            },
            toggleVertexNumbers() {
                this.showVertexNumbers = !this.showVertexNumbers;
                DOM.valVertex.textContent = this.showVertexNumbers ? 'On' : 'Off';
                this.markers.forEach((m, idx) => {
                    m.setIcon(L.divIcon({
                        className: 'map-point-icon',
                        html: this.showVertexNumbers ? idx + 1 : ''
                    }));
                });
                requestRender();
            },
            toggleBoundingBox() {
                this.showBoundingBox = !this.showBoundingBox;
                DOM.valBbox.textContent = this.showBoundingBox ? 'On' : 'Off';
                requestRender();
            },
            clear() {
                this.groundTruth = null;
                this.markers = [];
                resetLayers();
                requestRender(); this.updateUI();
            },
            removeLast() {
                if (!this.groundTruth) return;
                if (this.groundTruth.localPoints.length <= 1) this.clear();
                else {
                    const om = this.groundTruth.origin_map;
                    const map = om === 1 ? map1 : map2;
                    this.groundTruth.removeLastPoint(map); // Handles anchor shift

                    if (this.markers.length > 0) {
                        const m = this.markers.pop();
                        mk1.removeLayer(m); mk2.removeLayer(m); // Markers are shared in the array but exist on one map
                    }
                    resetLayers();
                    requestRender();
                    this.updateUI();
                }
            },
            updateUI() {
                const hasGt = !!this.groundTruth;
                const om = hasGt ? this.groundTruth.origin_map : 0;
                [1, 2].forEach(id => {
                    DOM.backBtn[id].classList.toggle('hidden', om !== id);
                    DOM.centerBtn[id].classList.toggle('hidden', om !== id);
                    DOM.clearBtn[id].classList.toggle('hidden', om !== id);
                    DOM.card[id].classList.toggle('visible', hasGt && this.groundTruth.localPoints.length >= 2);
                    if (hasGt) {
                        const color = getCssVar(om === id ? '--origin-color' : '--comp-color');
                        DOM.stats[id].style.color = color;
                        if (om === id) document.documentElement.style.setProperty('--shape-point-color', color);
                    }
                });
            }
        };

        const DOM = {
            layerMenu: document.getElementById('layerMenu'),
            layerBtn: document.getElementById('layerBtn'),
            modeGroup: document.getElementById('mode-group'),
            btnLine: document.getElementById('btnLine'),
            btnArea: document.getElementById('btnArea'),
            magnifier: document.getElementById('magnifier'),
            shareModal: document.getElementById('share-modal'),
            settingsModal: document.getElementById('settings-modal'),
            infoModal: document.getElementById('info-modal'),
            shareUrl: document.getElementById('share-url'),
            qrcode: document.getElementById('qrcode'),
            qrLoading: document.getElementById('qr-loading'),
            qrError: document.getElementById('qr-error'),
            btnCopyLink: document.getElementById('btn-copy-link'),
            appContainer: document.getElementById('app-container'),
            stats: [null, document.getElementById('stats1'), document.getElementById('stats2')],
            diff: [null, document.getElementById('diff1'), document.getElementById('diff2')],
            card: [null, document.getElementById('card1'), document.getElementById('card2')],
            backBtn: [null, document.getElementById('back1'), document.getElementById('back2')],
            centerBtn: [null, document.getElementById('center-btn1'), document.getElementById('center-btn2')],
            clearBtn: [null, document.getElementById('clear1'), document.getElementById('clear2')],
            searchCtrl: [null, document.getElementById('search-ctrl1'), document.getElementById('search-ctrl2')],
            searchIn: [null, document.getElementById('search-in1'), document.getElementById('search-in2')],
            searchResults: [null, document.getElementById('results1'), document.getElementById('results2')],
            resultsList: [null, document.getElementById('results-list1'), document.getElementById('results-list2')],
            searchStatus: {
                searching: [null, document.getElementById('status-searching1'), document.getElementById('status-searching2')],
                none: [null, document.getElementById('status-none1'), document.getElementById('status-none2')],
                error: [null, document.getElementById('status-error1'), document.getElementById('status-error2')]
            },
            locateBtn: [null, document.getElementById('locate-btn1'), document.getElementById('locate-btn2')],
            valUnits: document.getElementById('val-units'),
            valVertex: document.getElementById('val-vertex'),
            valBbox: document.getElementById('val-bbox'),
            dropdownItems: document.querySelectorAll('.dropdown-item')
        };

        const fg1 = L.featureGroup().addTo(map1);
        const mk1 = L.featureGroup().addTo(map1);
        const bb1 = L.featureGroup().addTo(map1);
        const hd1 = L.featureGroup().addTo(map1); // Handles layer for map1

        const fg2 = L.featureGroup().addTo(map2);
        const mk2 = L.featureGroup().addTo(map2);
        const bb2 = L.featureGroup().addTo(map2);
        const hd2 = L.featureGroup().addTo(map2); // Handles layer for map2

        // Persistent handle references
        const h1 = { move: null, rotate: null, line: null };
        const h2 = { move: null, rotate: null, line: null };

        // Persistent layer objects to prevent flickering
        let shape1, shape2, casing1, casing2, bbox1, bbox2;

        function resetLayers() {
            fg1.clearLayers(); fg2.clearLayers();
            bb1.clearLayers(); bb2.clearLayers();
            mk1.clearLayers(); mk2.clearLayers();
            hd1.clearLayers(); hd2.clearLayers();
            h1.move = h1.rotate = h1.line = null;
            h2.move = h2.rotate = h2.line = null;
            shape1 = shape2 = casing1 = casing2 = bbox1 = bbox2 = null;
            AppState.markers = [];
        }

        let renderPending = false;
        function requestRender() {
            if (renderPending) return;
            renderPending = true;
            requestAnimationFrame(() => {
                renderAll();
                renderPending = false;
            });
        }

        function renderAll() {
            if (!AppState.groundTruth) { resetLayers(); return; }

            const pts1 = AppState.groundTruth.getRenderPoints(map1, 1);
            const pts2 = AppState.groundTruth.getRenderPoints(map2, 2);
            const om = AppState.groundTruth.origin_map;

            const color1 = getCssVar(om === 1 ? '--origin-color' : '--comp-color');
            const color2 = getCssVar(om === 2 ? '--origin-color' : '--comp-color');

            updateShape(pts1, 1, color1);
            updateShape(pts2, 2, color2);

            if (AppState.showBoundingBox) {
                updateBBox(pts1, 1);
                updateBBox(pts2, 2);
            } else {
                bb1.clearLayers(); bb2.clearLayers();
                bbox1 = bbox2 = null;
            }

            syncMarkers(om === 1 ? pts1 : pts2, om === 1 ? mk1 : mk2, om === 1 ? map1 : map2);
            syncOverlayHandles(om === 1 ? map2 : map1, om === 1 ? hd2 : hd1, om === 1 ? 2 : 1);

            const val1 = getVal(pts1); const val2 = getVal(pts2);
            DOM.stats[1].textContent = format(val1);
            DOM.stats[2].textContent = format(val2);

            const refVal = om === 1 ? val1 : val2;
            const compVal = om === 1 ? val2 : val1;
            DOM.diff[om === 1 ? 1 : 2].textContent = '';

            if (refVal > 0) {
                const pct = ((compVal - refVal) / refVal) * 100;
                const el = DOM.diff[om === 1 ? 2 : 1];
                el.textContent = `${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%`;
                el.style.color = getCssVar('--comp-color');
            }
        }

        function updateShape(pts, id, color) {
            if (pts.length < 2) return;
            const layer = id === 1 ? fg1 : fg2;
            let shape = id === 1 ? shape1 : shape2;
            let casing = id === 1 ? casing1 : casing2;

            const weight = parseInt(getCssVar('--shape-line-width')) || 3;
            const isArea = AppState.mode === 'area' && pts.length > 2;
            const factory = isArea ? L.polygon : L.polyline;

            if (!shape || (isArea && !(shape instanceof L.Polygon)) || (!isArea && shape instanceof L.Polygon)) {
                layer.clearLayers();
                casing = factory(pts, { color: getCssVar('--shape-outline-color'), weight: weight * 2, fill: false, opacity: 1, interactive: false }).addTo(layer);
                shape = factory(pts, { color, weight, fill: isArea, fillColor: color, fillOpacity: 0.25, opacity: 1, interactive: false }).addTo(layer);
                if (id === 1) { shape1 = shape; casing1 = casing; } else { shape2 = shape; casing2 = casing; }
            } else {
                shape.setLatLngs(pts);
                casing.setLatLngs(pts);
                shape.setStyle({ color, fillColor: color });
            }
        }

        function updateBBox(pts, id) {
            if (pts.length < 2) return;
            const layer = id === 1 ? bb1 : bb2;
            let bbox = id === 1 ? bbox1 : bbox2;
            const bounds = L.latLngBounds(pts);

            if (!bbox) {
                const color = getCssVar('--bbox-color');
                const weight = parseFloat(getCssVar('--bbox-width')) || 1.5;
                bbox = L.rectangle(bounds, { color, weight, dashArray: '5, 5', fill: false, interactive: false }).addTo(layer);
                if (id === 1) bbox1 = bbox; else bbox2 = bbox;
            } else {
                bbox.setBounds(bounds);
            }
        }

        function syncMarkers(pts, layer, map) {
            if (AppState.markers.length !== pts.length) {
                layer.clearLayers();
                AppState.markers = pts.map((p, i) => {
                    const m = L.marker(p, {
                        icon: L.divIcon({
                            className: 'map-point-icon',
                            html: AppState.showVertexNumbers ? i + 1 : '',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        }),
                        draggable: true
                    }).addTo(layer);

                    m.on('dragstart', (e) => {
                        AppState.isDraggingPoint = i;
                        initMagnifier(map, e.target.getLatLng());
                    });
                    m.on('dragend', () => {
                        AppState.isDraggingPoint = -1;
                        hideMagnifier();
                        requestRender();
                    });

                    m.on('drag', e => {
                        const latlng = e.target.getLatLng();
                        AppState.groundTruth.updatePoint(i, latlng, map);
                        updateMagnifier(latlng, map);
                        requestRender();
                    });
                    return m;
                });
                pts.forEach((p, i) => {
                    if (AppState.isDraggingPoint !== i) {
                        AppState.markers[i].setLatLng(p);
                    }
                });
            }
        }

        // Handles for rigid transformation (Compare Map)
        function syncOverlayHandles(map, layer, mapId) {
            const handles = mapId === 1 ? h1 : h2;
            const offsetDist = 80; // Constant radius in screenview space (px)

            if (!AppState.groundTruth) {
                if (handles.move) { layer.clearLayers(); handles.move = handles.rotate = handles.line = null; }
                return;
            }

            const center = AppState.groundTruth.comparison_anchor;

            // 1. Move Handle (Center)
            if (!handles.move) {
                handles.move = L.marker(center, {
                    draggable: true,
                    icon: L.divIcon({
                        className: 'handle-icon handle-move',
                        html: '<img src="images/svgs/move.svg">',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(layer);

                handles.move.on('dragstart', () => {
                    AppState.isDragging = true;
                });
                handles.move.on('dragend', () => {
                    AppState.isDragging = false;
                    AppState.isDragEnd = true;
                    setTimeout(() => AppState.isDragEnd = false, 100);
                    requestRender();
                });
                handles.move.on('drag', e => {
                    const latlng = e.target.getLatLng();
                    AppState.groundTruth.setOverlayPosition(latlng);
                    renderAll();
                });
            } else {
                if (!AppState.isDragging) handles.move.setLatLng(center);
            }

            // 2. Rotation Handle Calculation
            const mapZoom = map.getZoom();
            const centerPx = map.project(center, mapZoom);
            const rot = AppState.groundTruth.overlayRotation;

            // Calculate position on circle at current rotation
            const rx = Math.sin(rot) * offsetDist;
            const ry = -Math.cos(rot) * offsetDist;
            const handlePos = map.unproject(centerPx.add(L.point(rx, ry)), mapZoom);

            // 3. Rotation Handle
            if (!handles.rotate) {
                handles.rotate = L.marker(handlePos, {
                    draggable: true,
                    icon: L.divIcon({
                        className: 'handle-icon handle-rotate',
                        html: '<img src="images/svgs/rotate.svg">',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(layer);

                handles.rotate.on('dragstart', () => {
                    AppState.isRotating = true;
                });
                handles.rotate.on('dragend', () => {
                    AppState.isRotating = false;
                    AppState.isDragEnd = true;
                    setTimeout(() => AppState.isDragEnd = false, 100);
                    requestRender();
                });

                handles.rotate.on('drag', e => {
                    const latlng = e.target.getLatLng();
                    const c = AppState.groundTruth.comparison_anchor;
                    const cPx = map.project(c, map.getZoom());
                    const mPx = map.project(e.target.getLatLng(), map.getZoom());

                    // Calculate angle from center to mouse
                    const angle = Math.atan2(mPx.y - cPx.y, mPx.x - cPx.x);

                    // Constrain the handle position to the circle during drag
                    const dx = Math.cos(angle) * offsetDist;
                    const dy = Math.sin(angle) * offsetDist;
                    const constrainedLatLng = map.unproject(cPx.add(L.point(dx, dy)), map.getZoom());
                    e.target.setLatLng(constrainedLatLng);

                    AppState.groundTruth.setOverlayRotation(angle + Math.PI / 2);
                    renderAll();
                });
            } else {
                // Update position to stay on circle relative to center & rotation
                if (!AppState.isRotating) handles.rotate.setLatLng(handlePos);
            }

            // 4. Connector Line
            const linePts = [center, handlePos];
            if (!handles.line) {
                handles.line = L.polyline(linePts, {
                    color: getCssVar('--accent-yellow'),
                    weight: 2,
                    dashArray: '5, 5',
                    opacity: 0.6,
                    interactive: false
                }).addTo(layer);
            } else {
                handles.line.setLatLngs(linePts);
            }
        }

        function getVal(pts) {
            if (pts.length < 2) return 0;
            if (AppState.mode === 'area') {
                const ref = pts[0];
                const loc = pts.map(p => ({ x: p.distanceTo(L.latLng(p.lat, ref.lng)) * (p.lng > ref.lng ? 1 : -1), y: p.distanceTo(L.latLng(ref.lat, p.lng)) * (p.lat > ref.lat ? 1 : -1) }));
                let a = 0; for (let i = 0; i < loc.length; i++) { let j = (i + 1) % loc.length; a += loc[i].x * loc[j].y - loc[j].x * loc[i].y; }
                return Math.abs(a) / 2;
            }
            let d = 0; for (let i = 0; i < pts.length - 1; i++) d += pts[i].distanceTo(pts[i + 1]);
            return d;
        }

        function format(v) {
            if (v === 0) return '---';
            const isM = AppState.units === 'metric';
            if (AppState.mode === 'area') {
                if (isM) {
                    return v >= 1e6 ? (v / 1e6).toFixed(2) + ' km2' : v.toFixed(0) + ' m2';
                } else {
                    const yd2 = v * 1.19599;
                    return yd2 >= 3097600 ? (v * 3.861e-7).toFixed(2) + ' mi2' : yd2.toFixed(0) + ' yd2';
                }
            } else {
                if (isM) {
                    return v >= 1000 ? (v / 1000).toFixed(2) + ' km' : v.toFixed(0) + ' m';
                } else {
                    const yd = v * 1.09361;
                    return yd >= 1760 ? (v * 0.000621371).toFixed(2) + ' mi' : yd.toFixed(0) + ' yd';
                }
            }
        }

        function centerShapes() {
            if (!AppState.groundTruth) return;
            const pts1 = AppState.groundTruth.getRenderPoints(map1, 1);
            const pts2 = AppState.groundTruth.getRenderPoints(map2, 2);

            const bounds1 = L.latLngBounds(pts1);
            const bounds2 = L.latLngBounds(pts2);

            map1.fitBounds(bounds1, { padding: [80, 80], animate: true });
            map2.fitBounds(bounds2, { padding: [80, 80], animate: true });
        }

        function getInsertIndex(latlng, m) {
            const shape = AppState.groundTruth;
            if (!shape || shape.localPoints.length < 2) return -1;
            const pts = shape.getRenderPoints(m, shape.origin_map);
            const clickPx = m.latLngToLayerPoint(latlng);
            let minDist = Infinity;
            let index = -1;
            const threshold = 15;
            const isArea = AppState.mode === 'area';
            const limit = isArea ? pts.length : pts.length - 1;
            for (let i = 0; i < limit; i++) {
                const p1 = m.latLngToLayerPoint(pts[i]);
                const p2 = m.latLngToLayerPoint(pts[(i + 1) % pts.length]);
                const closest = L.LineUtil.closestPointOnSegment(clickPx, p1, p2);
                const dist = clickPx.distanceTo(closest);
                if (dist < threshold && dist < minDist) {
                    minDist = dist;
                    index = i + 1;
                }
            }
            return index;
        }

        [map1, map2].forEach((m, i) => {
            m.on('click', e => {
                if (AppState.isDragEnd || AppState.isDragging || AppState.isRotating) return;

                if (!AppState.groundTruth) {
                    AppState.init(e.latlng, i + 1);
                } else {
                    const latlng = e.latlng;
                    if (AppState.groundTruth.origin_map === (i + 1)) {
                        // Origin map: Add or insert a new point
                        const idx = getInsertIndex(latlng, m);
                        AppState.groundTruth.addPoint(latlng, m, idx);
                    } else {
                        // Comparison map: Reposition the entire shape reference
                        AppState.groundTruth.setOverlayPosition(latlng);
                    }
                }
                requestRender(); AppState.updateUI();
            });
            m.on('viewreset move', () => requestRender());
        });


        function toggleSearch(id) {
            const ctrl = DOM.searchCtrl[id];
            const resDiv = DOM.searchResults[id];
            const input = DOM.searchIn[id];

            ctrl.classList.toggle('expanded');

            if (ctrl.classList.contains('expanded')) {
                input.focus();
            } else {
                resDiv.style.display = 'none';
                DOM.resultsList[id].textContent = '';
                input.value = '';
            }
        }

        function toggleLayerMenu() {
            const isShowing = DOM.layerMenu.classList.contains('show');
            document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('show'));
            if (!isShowing) {
                DOM.layerMenu.classList.add('show');
                DOM.layerBtn.classList.add('active');
            } else {
                DOM.layerMenu.classList.remove('show');
                DOM.layerBtn.classList.remove('active');
            }
        }

        function toggleModal(id, s) { 
            const modal = { 'share-modal': DOM.shareModal, 'settings-modal': DOM.settingsModal, 'info-modal': DOM.infoModal }[id];
            if (modal) modal.classList.toggle('show', s);
        }

        /**
         * Share Data Binary Format (Version 1)
         * URL-safe base64 encoded binary blob
         * 
         * Byte Layout:
         * [0]     - Version (0x01)
         * [1]     - Flags byte:
         *           Bits 0-1: Layer (0=hybrid, 1=satellite, 2=streets)
         *           Bit 2:    Mode (0=line, 1=area)
         *           Bit 3:    Units (0=metric, 1=imperial)
         *           Bit 4:    Vertex Numbers (0=off, 1=on)
         *           Bit 5:    Bounding Box (0=off, 1=on)
         *           Bits 6-7: Reserved
         * [2-9]   - Reserved buffer (8 bytes for future settings)
         * [10-17] - Map 1 State: lat (f32), lng (f32), zoom*100 (u16)
         * [18-25] - Map 2 State: lat (f32), lng (f32), zoom*100 (u16)
         * [26]    - Has Shape flag (0=no shape, 1=has shape)
         * [27+]   - Shape Data (if present):
         *           [0]    - Origin map (1 or 2)
         *           [1-8]  - Origin anchor: lat (f32), lng (f32)
         *           [9-16] - Comparison anchor: lat (f32), lng (f32)
         *           [17-20]- Rotation (f32 radians)
         *           [21-22]- Point count (u16)
         *           [23+ ] - Points: x (f32), y (f32) each
         */
        const ShareState = {
            // Binary Helper
            Bin: {
                w: [], dV: new DataView(new ArrayBuffer(8)),
                r_u8: null, r_idx: 0,
                reset() { this.w = []; },
                wU8(v) { this.w.push(v & 0xFF); },
                wU16(v) { this.w.push((v >> 8) & 0xFF, v & 0xFF); },
                wF32(v) { this.dV.setFloat32(0, v); this.w.push(this.dV.getUint8(0), this.dV.getUint8(1), this.dV.getUint8(2), this.dV.getUint8(3)); },
                initRead(u8) { this.r_u8 = u8; this.r_idx = 0; },
                rU8() { return this.r_u8[this.r_idx++]; },
                rU16() { const v = (this.r_u8[this.r_idx] << 8) | this.r_u8[this.r_idx + 1]; this.r_idx += 2; return v; },
                rF32() {
                    this.dV.setUint8(0, this.r_u8[this.r_idx]); this.dV.setUint8(1, this.r_u8[this.r_idx + 1]);
                    this.dV.setUint8(2, this.r_u8[this.r_idx + 2]); this.dV.setUint8(3, this.r_u8[this.r_idx + 3]);
                    this.r_idx += 4; return this.dV.getFloat32(0);
                },
                toB64() {
                    const u8 = new Uint8Array(this.w);
                    let bin = ''; for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
                    return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                },
                fromB64(str) {
                    str = str.replace(/-/g, '+').replace(/_/g, '/');
                    while (str.length % 4) str += '=';
                    const bin = atob(str);
                    const u8 = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
                    return u8;
                }
            },

            encode() {
                try {
                    this.Bin.reset();
                    // 1. Version (0x01)
                    this.Bin.wU8(1);

                    // 2. Flags
                    // Bits 0-1: Layer (0,1,2)
                    let lIdx = layerOrder.indexOf(document.getElementById('layerMenu').dataset.active);
                    if (lIdx === -1) lIdx = 0;
                    // Bit 2: Mode (0=line, 1=area)
                    const mBit = AppState.mode === 'area' ? 1 : 0;
                    // Bit 3: Units (0=metric, 1=imperial)
                    const uBit = AppState.units === 'imperial' ? 1 : 0;
                    // Bit 4: Vertex Numbers
                    const vBit = AppState.showVertexNumbers ? 1 : 0;
                    // Bit 5: BBox
                    const bBit = AppState.showBoundingBox ? 1 : 0;

                    const flags = (lIdx & 0x03) | ((mBit & 1) << 2) | ((uBit & 1) << 3) | ((vBit & 1) << 4) | ((bBit & 1) << 5);
                    this.Bin.wU8(flags);

                    // 3. Reserved buffer (8 bytes for future settings)
                    for (let i = 0; i < 8; i++) {
                        this.Bin.wU8(0);
                    }

                    // 4. Map 1 State
                    const c1 = map1.getCenter();
                    this.Bin.wF32(c1.lat); this.Bin.wF32(c1.lng);
                    this.Bin.wU16(Math.round(map1.getZoom() * 100));

                    // 5. Map 2 State
                    const c2 = map2.getCenter();
                    this.Bin.wF32(c2.lat); this.Bin.wF32(c2.lng);
                    this.Bin.wU16(Math.round(map2.getZoom() * 100));

                    // 6. Shape Data
                    if (AppState.groundTruth) {
                        this.Bin.wU8(1); // Has shape
                        const gt = AppState.groundTruth;
                        this.Bin.wU8(gt.origin_map);
                        this.Bin.wF32(gt.origin_anchor.lat); this.Bin.wF32(gt.origin_anchor.lng);
                        this.Bin.wF32(gt.comparison_anchor.lat); this.Bin.wF32(gt.comparison_anchor.lng);
                        this.Bin.wF32(gt.overlayRotation);
                        this.Bin.wU16(gt.localPoints.length);
                        gt.localPoints.forEach(p => {
                            this.Bin.wF32(p.x); this.Bin.wF32(p.y);
                        });
                    } else {
                        this.Bin.wU8(0); // No shape
                    }

                    return this.Bin.toB64();
                } catch (e) {
                    console.error("Encoding error:", e);
                    return null;
                }
            },

            decode(str) {
                try {
                    const u8 = this.Bin.fromB64(str);
                    this.Bin.initRead(u8);

                    const ver = this.Bin.rU8();
                    if (ver !== 1) { console.warn("Unsupported state version:", ver); return; }

                    const flags = this.Bin.rU8();
                    const lIdx = flags & 0x03;
                    const mBit = (flags >> 2) & 1;
                    const uBit = (flags >> 3) & 1;
                    const vBit = (flags >> 4) & 1;
                    const bBit = (flags >> 5) & 1;

                    // Skip reserved buffer (8 bytes for future settings)
                    for (let i = 0; i < 8; i++) this.Bin.rU8();

                    // Apply Settings
                    const layerName = layerOrder[lIdx] || 'hybrid';
                    AppState.setLayer(layerName);
                    AppState.setMode(mBit === 1 ? 'area' : 'line');
                    if ((uBit === 1 && AppState.units === 'metric') || (uBit === 0 && AppState.units === 'imperial')) AppState.toggleUnits();
                    if ((vBit === 1 && !AppState.showVertexNumbers) || (vBit === 0 && AppState.showVertexNumbers)) AppState.toggleVertexNumbers();
                    if ((bBit === 1 && !AppState.showBoundingBox) || (bBit === 0 && AppState.showBoundingBox)) AppState.toggleBoundingBox();

                    // Map 1
                    const lat1 = this.Bin.rF32(); const lng1 = this.Bin.rF32();
                    const z1 = this.Bin.rU16() / 100;
                    map1.setView([lat1, lng1], z1, { animate: false });

                    // Map 2
                    const lat2 = this.Bin.rF32(); const lng2 = this.Bin.rF32();
                    const z2 = this.Bin.rU16() / 100;
                    map2.setView([lat2, lng2], z2, { animate: false });

                    // Shape
                    const hasShape = this.Bin.rU8();
                    if (hasShape === 1) {
                        const om = this.Bin.rU8();
                        const oaLat = this.Bin.rF32(); const oaLng = this.Bin.rF32();
                        const caLat = this.Bin.rF32(); const caLng = this.Bin.rF32();
                        const rot = this.Bin.rF32();
                        const count = this.Bin.rU16();

                        AppState.clear();
                        // Re-init
                        // Note: AppState.init uses map center for default comparison anchor, 
                        // but we will overwrite it immediately.
                        AppState.init([oaLat, oaLng], om);

                        const gt = AppState.groundTruth;
                        gt.comparison_anchor = L.latLng(caLat, caLng);
                        gt.overlayRotation = rot;

                        // Read points
                        gt.localPoints = [];
                        for (let i = 0; i < count; i++) {
                            const x = this.Bin.rF32();
                            const y = this.Bin.rF32();
                            gt.localPoints.push(L.point(x, y));
                        }

                        requestRender();
                        AppState.updateUI();
                    } else {
                        AppState.clear();
                    }

                } catch (e) {
                    console.error("Decoding error:", e);
                }
            }
        };

        function shareCurrentView() {
            const code = ShareState.encode();
            if (!code) return;

            const url = new URL(window.location.href);
            url.searchParams.set('s', code);
            const strUrl = url.toString();

            // Update local history so we don't lose state on refresh
            window.history.replaceState({}, '', strUrl);

            // Strict detection: if it's mobile AND has navigator.share, ONLY use that.
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                window.matchMedia("(max-width: 768px)").matches;

            if (isMobile) {
                if (navigator.share) {
                    navigator.share({ title: 'Sync View', url: strUrl }).catch(() => { });
                } else {
                    // Mobile fallback: just copy the link (with the bar-btn feedback)
                    copyToClipboard(strUrl);
                }
                return;
            }

            // Desktop logic: show custom QR/copy modal
            openShareModal(strUrl);
        }

        function openShareModal(url) {
            toggleModal('share-modal', true);
            if (DOM.shareUrl) DOM.shareUrl.innerText = url;

            if (DOM.qrcode) {
                DOM.qrcode.textContent = '';
                DOM.qrLoading.classList.remove('hidden');
                DOM.qrError.classList.add('hidden');

                setTimeout(() => {
                    try {
                        new QRCode(DOM.qrcode, {
                            text: url,
                            width: 200,
                            height: 200,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.M
                        });
                        DOM.qrLoading.classList.add('hidden');
                    } catch (e) {
                        DOM.qrLoading.classList.add('hidden');
                        DOM.qrError.classList.remove('hidden');
                    }
                }, 50);
            }

            if (DOM.btnCopyLink) {
                DOM.btnCopyLink.onclick = () => {
                    copyToClipboard(url);
                    const span = DOM.btnCopyLink.querySelector('span');
                    if (span) {
                        const originalText = span.innerText;
                        span.innerText = 'COPIED!';
                        setTimeout(() => {
                            span.innerText = originalText;
                            toggleModal('share-modal', false);
                        }, 1000);
                    }
                };
            }
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(fallbackCopy);
            } else {
                fallbackCopy();
            }

            function fallbackCopy() {
                const el = document.createElement('textarea');
                el.value = text;
                document.body.appendChild(el);
                el.select();
                try { document.execCommand('copy') } catch (e) { }
                document.body.removeChild(el);
            }
        }

        // Global click to close dropdowns
        window.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown-container')) {
                document.getElementById('layerMenu').classList.remove('show');
                document.getElementById('layerBtn').classList.remove('active');
            }
            // Close search if clicked outside its wrapper
            [1, 2].forEach(id => {
                const ctrl = document.getElementById(`search-ctrl${id}`);
                if (!ctrl || !ctrl.classList.contains('expanded')) return;
                const wrapper = ctrl.closest('.search-wrapper');
                if (wrapper && !wrapper.contains(e.target)) {
                    toggleSearch(id);
                }
            });
        });

        window.addEventListener('keydown', (e) => {
            const target = e.target.tagName.toLowerCase();
            const isInput = target === 'input' || target === 'textarea';

            if (e.key === 'Escape') {
                let searchWasOpen = false;
                [1, 2].forEach(id => {
                    const ctrl = document.getElementById(`search-ctrl${id}`);
                    if (ctrl && ctrl.classList.contains('expanded')) {
                        toggleSearch(id);
                        searchWasOpen = true;
                    }
                });
                if (searchWasOpen) return;

                const openModal = document.querySelector('.modal-overlay.show');
                if (openModal) {
                    toggleModal(openModal.id, false);
                    return;
                }

                if (!isInput) AppState.clear();
                else e.target.blur();
                return;
            }

            if (isInput) return;
            if (e.key.toLowerCase() === 'l') AppState.setMode('line');
            if (e.key.toLowerCase() === 'a') AppState.setMode('area');
            if (e.key.toLowerCase() === 'u') AppState.toggleUnits();
            if (e.key.toLowerCase() === 'v') AppState.toggleVertexNumbers();
            if (e.key.toLowerCase() === 'b') AppState.toggleBoundingBox();
            if (e.key === 'Delete' || e.key === 'Backspace') AppState.removeLast();
            if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                AppState.removeLast();
            }
        });

        async function handleSearch(e, id) {
            const q = e.target.value.trim();
            const resDiv = DOM.searchResults[id];
            const listDiv = DOM.resultsList[id];
            const sSearching = DOM.searchStatus.searching[id];
            const sNone = DOM.searchStatus.none[id];
            const sError = DOM.searchStatus.error[id];

            const hideStatus = () => {
                sSearching.classList.add('hidden');
                sNone.classList.add('hidden');
                sError.classList.add('hidden');
            };

            if (q.length < 2) {
                resDiv.style.display = 'none';
                listDiv.textContent = '';
                hideStatus();
                return;
            }

            listDiv.textContent = '';
            hideStatus();
            sSearching.classList.remove('hidden');
            resDiv.style.display = 'flex';

            try {
                const response = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&limit=5`);
                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                hideStatus();

                if (!data.features || data.features.length === 0) {
                    sNone.classList.remove('hidden');
                    return;
                }

                data.features.forEach(feature => {
                    const p = feature.properties;
                    const coords = feature.geometry.coordinates;

                    const nameParts = [p.name, p.street, p.city, p.country].filter(Boolean);
                    const uniqueParts = [...new Set(nameParts)];
                    const label = uniqueParts.join(', ');

                    const d = document.createElement('div');
                    d.className = 'result-item';
                    d.textContent = label;
                    d.onclick = () => {
                        (id === 1 ? map1 : map2).setView([coords[1], coords[0]], 15);
                        toggleSearch(id);
                    };
                    listDiv.appendChild(d);
                });
            } catch (err) {
                console.error('Search error:', err);
                hideStatus();
                sError.classList.remove('hidden');
            }
        }

        function initMagnifier(sourceMap, latlng) {
            if (!AppState.showLens) return;
            DOM.magnifier.style.display = 'block';

            if (!AppState.magnifierMap) {
                AppState.magnifierMap = L.map('magnifier', {
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    touchZoom: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    inertia: false
                });
                const currentLayer = DOM.layerMenu.dataset.active || 'hybrid';
                AppState.magnifierTile = L.tileLayer(tiles[currentLayer], { ...tileOptions }).addTo(AppState.magnifierMap);
            }

            AppState.magnifierMap.invalidateSize({ pan: false });

            const currentLayer = DOM.layerMenu.dataset.active || 'hybrid';
            AppState.magnifierTile.setUrl(tiles[currentLayer]);

            const targetZoom = Math.min(sourceMap.getZoom() + 2, 22);
            AppState.magnifierMap.setView(latlng, targetZoom, { animate: false });
            updateMagnifier(latlng, sourceMap);
        }

        function updateMagnifier(latlng, sourceMap) {
            if (!AppState.showLens || !AppState.magnifierMap) return;
            const p = sourceMap.latLngToContainerPoint(latlng);
            const mapRect = sourceMap.getContainer().getBoundingClientRect();
            const globalX = p.x + mapRect.left;
            const globalY = p.y + mapRect.top;
            const lensSize = 140;
            DOM.magnifier.style.left = (globalX - lensSize / 2) + 'px';
            DOM.magnifier.style.top = (globalY - lensSize - AppState.lensOffset) + 'px';
            const targetZoom = Math.min(sourceMap.getZoom() + 2, 22);
            AppState.magnifierMap.setView(latlng, targetZoom, { animate: false });
        }

        function hideMagnifier() {
            DOM.magnifier.style.display = 'none';
        }

        const debouncedSearch = ((fn, ms) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, a), ms); }; })(handleSearch, 400);
        function locateDevice(id) {
            const btn = DOM.locateBtn[id];
            if (btn) btn.classList.add('loading');
            navigator.geolocation.getCurrentPosition(
                p => {
                    (id === 1 ? map1 : map2).setView([p.coords.latitude, p.coords.longitude], 15);
                    if (btn) btn.classList.remove('loading');
                },
                err => {
                    console.error(err);
                    if (btn) btn.classList.remove('loading');
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        window.addEventListener('load', () => {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('s');
            if (code) {
                setTimeout(() => ShareState.decode(code), 100);
            }
        });
    </script>
</body>

</html>